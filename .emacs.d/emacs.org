#+TITLE: My Emacs Configuration
#+AUTHOR: Alex Griffin
#+STARTUP: content
#+PROPERTY: header-args :tangle ~/.emacs.d/emacs.el

* General

This file describes my GNU Emacs configuration in a literate
programming style. Run the Emacs command =org-babel-tangle= on this
document to generate the actual config.

** Initialization

*** Optimize startup time

From doom-emacs and John Wiegley.

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-

  (defvar file-name-handler-alist-old file-name-handler-alist)

  ;; Only run this code once, even when reloading the file.
  (defvar pre-init-p t)
  (when pre-init-p
    (setq file-name-handler-alist nil
          pre-init-p nil
          gc-cons-threshold 402653184
          gc-cons-percentage 0.6
          load-prefer-newer t
          package-enable-at-startup nil
          package--init-file-ensured t))

  (add-hook 'after-init-hook
            `(lambda ()
               (setq file-name-handler-alist file-name-handler-alist-old
                     gc-cons-threshold 800000
                     gc-cons-percentage 0.1)
               (garbage-collect))
            t)
#+END_SRC

*** Persistence Files

Use a separate file for customization system.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file t)
#+END_SRC

Don't litter the filesystem with backup or auto-save files.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-save/") t)))
#+END_SRC

Save minibuffer history.

#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
#+END_SRC

*** Package Management

**** Specify Package Repositories

Use TLS for ELPA, and add MELPA as an additional repository.

#+BEGIN_SRC emacs-lisp
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")))
#+END_SRC

**** Bootstrap use-package

Every other package will be managed by use-package.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'package)
    (package-initialize)
    (unless (locate-library "use-package")
      (package-refresh-contents)
      (package-install 'use-package))
    (require 'use-package)
    (use-package diminish))
  (require 'bind-key)
#+END_SRC

Don't load a package if it's not installed.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'use-package-defaults
               '(:when
                 (lambda (package &rest _)
                   `(locate-library (symbol-name ',package)))
                 t))
#+END_SRC

** Interface Elements

Emacs' interface is a little too busy for me by default.

Disable the tool bar and menu bar.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

Don't show the normal Emacs welcome screen or related messages.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (defun display-startup-echo-area-message ()
    (message ""))
#+END_SRC

Empty the scratch buffer and remove lisp-interaction-mode from it.

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil
        initial-major-mode 'fundamental-mode)
#+END_SRC

Set the window title format.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format "%b - GNU Emacs")
  (setq icon-title-format frame-title-format)
#+END_SRC

Disambiguate buffer names by adding its file path to the name when needed.

#+BEGIN_SRC emacs-lisp
  (set uniquify-buffer-name-style 'forward)
#+END_SRC

Set default window geometry.

#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((width . 80)
                              (height . 43)))
#+END_SRC

Scroll one line at a time.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 10000)
#+END_SRC

Prompt for 'y' or 'n' instead of 'yes' or 'no'.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Save cursor position to resume editing files.

#+BEGIN_SRC emacs-lisp
  (setq save-place-file (concat user-emacs-directory "places"))
  (save-place-mode 1)
#+END_SRC

Disable that infernal beep!

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore
        visible-bell nil)
#+END_SRC

Enable mouse support in terminal mode.

#+BEGIN_SRC emacs-lisp
  (xterm-mouse-mode 1)
#+END_SRC

Some miscellaneous settings from
[[https://github.com/technomancy/better-defaults][better-defaults]].

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t
        apropos-do-all t
        mouse-yank-at-point t
        require-final-newline t
        ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** Window Management

Focus follows mouse.

#+BEGIN_SRC emacs-lisp
  (setq mouse-autoselect-window t)
#+END_SRC

** Appearance

*** Theme

Use parchment, my own light theme inspired by Acme and Leuven.

#+BEGIN_SRC emacs-lisp
  (use-package parchment-theme
    :load-path "~/src/parchment"
    :config
    (setq custom-safe-themes t
          parchment-want-modify-tty-colors t)
    (load-theme 'parchment t))
#+END_SRC

Highlight matching braces & parentheses.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
#+END_SRC

*** Fonts

Set fonts, both now and when creating new frames (for ~emacsclient~).

#+BEGIN_SRC emacs-lisp
  (defun my-set-fonts (&optional frame)
    (set-face-font 'default           "Go Mono 11"   frame)
    (set-face-font 'fixed-pitch       "Noto Mono 11" frame)
    (set-face-font 'fixed-pitch-serif "Go Mono 11"   frame)
    (set-face-font 'variable-pitch    "Noto Sans 11" frame))
  (my-set-fonts)
  (add-hook 'after-make-frame-functions 'my-set-fonts)
#+END_SRC

*** Cursor

Highlight the line that the cursor is currently on.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC

Fix describe-face when using hl-line-mode. From
https://emacs.stackexchange.com/a/45719:

#+BEGIN_SRC emacs-lisp
  (defun my-face-at-point ()
    (symbol-name
     (or (let ((face (get-text-property (point) 'face)))
           (or (and (face-list-p face)
                    (car face))
               (and (symbolp face)
                    face)))
         'default)))

  (eval-after-load "hl-line"
    '(progn
       (advice-add 'counsel--face-at-point :override #'my-face-at-point)))
#+END_SRC

Don't blink the cursor and use a separate cursor color in Emacs mode.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (setq evil-normal-state-cursor '(box "#000000")
        evil-emacs-state-cursor  '(box "#7F5AB6"))
#+END_SRC

Use a blinking bar-style cursor in insert mode.

#+BEGIN_SRC emacs-lisp
  (setq evil-insert-state-cursor  '(bar "#000000"))
  (add-hook 'evil-insert-state-entry-hook (lambda () (blink-cursor-mode 1)))
  (add-hook 'evil-insert-state-exit-hook  (lambda () (blink-cursor-mode 0)))
#+END_SRC

*** Mode Line

I abuse some implementation details of =smart-mode-line= to put the
cursor position information on the right like vim.

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :config
    (setq sml/mode-width 'right
          sml/pre-modes-separator "  "
          sml/theme nil)
    (add-to-list 'sml/replacer-regexp-list
                 `(,(concat "^/vcsh:dotfiles:" (getenv "HOME")) ":Dot:~") t)
    ;; Override this function to get better spacing once we rearrange.
    (defun sml/fill-for-buffer-identification () "  ")
    (column-number-mode) ;; Show column number next to the line number.
    (sml/setup)
    ;; Rearrange mode-line to put position and line number on the right.
    (setq-default
     mode-line-format
     '("%e"
       mode-line-mule-info
       mode-line-client
       mode-line-modified
       mode-line-remote
       "  "
       mode-line-frame-identification
       mode-line-buffer-identification
       sml/pos-id-separator
       (vc-mode vc-mode)
       sml/pre-modes-separator
       mode-line-modes
       mode-line-misc-info
       mode-line-front-space
       mode-line-position
       mode-line-end-spaces)))
#+END_SRC

**** Hide Mode Lighters

Most of my =diminish= invocations are within =use-package=
declarations, but these modes are hidden the hard way.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "eldoc" '(diminish 'eldoc-mode))
#+END_SRC

* Editing

** Whitespace

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :diminish (whitespace-mode global-whitespace-mode)
    :config
    (setq whitespace-line-column 79
          whitespace-style '(face lines-tail trailing))
    (global-whitespace-mode 1))
#+END_SRC

Don't indent with tabs by default.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Sentences end with a single space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

Load style settings from =.editorconfig=

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :diminish
    :hook (prog-mode . editorconfig-mode)
    :commands editorconfig-mode)
  #+END_SRC

Automatically trim whitespace only from lines edited.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :diminish
    :hook (prog-mode . ws-butler-mode)
    :commands ws-butler-mode)
#+END_SRC

** Modal Editing

Evil is an extensible vi layer for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :diminish undo-tree-mode
    :init
    (setq evil-want-keybinding nil
          evil-want-C-u-scroll t)
    :config
    (defun backward-kill-line (arg)
      (interactive "p")
      (kill-line (- 1 arg)))
    (evil-define-key 'insert 'global
      (kbd "C-u") 'backward-kill-line)
    (setq evil-mode-line-format nil)
    (evil-mode 1))
#+END_SRC

*** Workman Layout

I need to use Workman bindings in evil-mode because I'm a snowflake.

#+BEGIN_SRC emacs-lisp
  (setq evil-workman (getenv "WORKMAN"))
#+END_SRC

Define the keys to translate.

#+BEGIN_SRC emacs-lisp
  (defvar workman-base-translations
    (list "n" "j"
          "e" "k"
          "y" "h"
          "o" "l"
          "j" "y"
          "k" "n"
          "h" "e"
          "l" "o")
    "The basic evil keys to translate for the Workman keyboard layout.")

  (defvar workman-translations
    (append workman-base-translations
            (mapcar #'upcase workman-base-translations)
            (mapcar (lambda (c) (kbd (concat "C-" c)))
                    workman-base-translations)
            (mapcar (lambda (c) (kbd (concat "M-" c)))
                    workman-base-translations))
    "Evil keys to translate for the Workman keyboard layout.")

  (defvar workman-extended-translations
    (append workman-translations
            (mapcar (lambda (c) (kbd (concat "g" c)))
                    workman-base-translations)
            (mapcar (lambda (c) (kbd (concat "g" (upcase c))))
                    workman-base-translations)
            (mapcar (lambda (c) (kbd (concat "z" c)))
                    workman-base-translations)
            (mapcar (lambda (c) (kbd (concat "z" (upcase c))))
                    workman-base-translations))
    "Extended set of Workman key translations (for evil keymaps).")
#+END_SRC

Fix my movement keys in modes that don't translate quite right.

#+BEGIN_SRC emacs-lisp
  (defmacro evil-add-yneo-bindings (keymap &optional state &rest bindings)
    "Add \"y\", \"n\", \"e\", \"o\" bindings to KEYMAP in STATE.
  Add additional BINDINGS if specified."
    (declare (indent defun))
    `(when evil-workman
       (evil-define-key ,state ,keymap
         "y" (lookup-key evil-motion-state-map "y")
         "n" (lookup-key evil-motion-state-map "n")
         "e" (lookup-key evil-motion-state-map "e")
         "o" (lookup-key evil-motion-state-map "o")
         ":" (lookup-key evil-motion-state-map ":")
         ,@bindings)))
#+END_SRC

Set up the translation in evil-collection's config.

#+NAME: evil-collection-workman
#+BEGIN_SRC emacs-lisp :tangle no
  (defun workman-translate-keys (mode keymaps &optional states &rest _rest)
    (let ((translations (if (or states (eq mode 'evil-mode))
                            workman-extended-translations
                          workman-translations)))
      (when (and evil-workman keymaps)
        (apply #'evil-collection-translate-key
               states
               keymaps
               translations))))

  (workman-translate-keys 'evil-mode
                          '(evil-normal-state-map
                            evil-motion-state-map
                            evil-visual-state-map
                            evil-window-map))

  (add-hook 'evil-collection-setup-hook #'workman-translate-keys)
#+END_SRC

*** Integration

Integrate evil with much of the rest of Emacs.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package evil-collection
    :after evil
    :config
    <<evil-collection-workman>>
    (evil-collection-init))
#+END_SRC

*** Surround

Edit pairs of surroundings together, like parentheses, brackets, quotes, tags.

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
#+END_SRC

*** Matchit

Extend % to jump between matching tags or code branches.

#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :after evil
    :config
    (global-evil-matchit-mode 1))
#+END_SRC

*** Commentary

Easily comment stuff out.

#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :diminish
    :config
    (workman-translate-keys 'evil-commentary-mode
                            'evil-commentary-mode-map
                            'normal)
    (evil-commentary-mode))
#+END_SRC

** Keybinding Popup

Show a popup with completions for partially-entered keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish
    :config (which-key-mode 1))
#+END_SRC

** Leader Keys

Use general.el to manage keybindings more easily and set up
Spacemacs-like leader keys.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :config
    (general-override-mode 1)
    (general-auto-unbind-keys)

    (defun find-emacs-config ()
      "Edit my Emacs configuration file in the current window."
      (interactive)
      (find-file-existing "/vcsh:dotfiles:~/.emacs.d/emacs.org"))

    (defun reload-emacs-config ()
      "Reload my Emacs configuration."
      (interactive)
      (require 'org)
      (org-babel-tangle-file "/vcsh:dotfiles:~/.emacs.d/emacs.org")
      (load-file user-init-file))

    (defun text-scale-reset ()
      "Disable text-scale-mode, returning text to normal size."
      (interactive)
      (text-scale-mode 0))


    (general-create-definer tyrant-def
      :states '(normal visual insert motion emacs)
      :keymaps 'override
      :prefix "SPC"
      :non-normal-prefix "C-SPC")

    (general-define-key
      :states '(normal visual)
      "," (general-simulate-key "SPC m"))

    (general-define-key
      :states 'insert
      "C-," (general-simulate-key "C-SPC m"))

    (tyrant-def
     "a"   '(:ignore t :which-key "app")
     "ac"  'calc
     "ad"  'dired
     "ak"  'list-packages
     "aP"  'proced
     "as"  '(:ignore t :which-key "shell")
     "ast" 'ansi-term
     "au"  'undo-tree-visualize

     "b"   '(:ignore t :which-key "buffer")
     "bb"  'ivy-switch-buffer
     "bd"  'evil-delete-buffer
     "bl"  'evil-switch-to-windows-last-buffer
     "bw"  'read-only-mode

     "f"   '(:ignore t :which-key "file")
     "fb"  'bookmark-jump
     "ff"  'find-file
     "fe"  '(:ignore t :which-key "emacs")
     "fed" 'find-emacs-config
     "feR" 'reload-emacs-config

     "h"   '(:ignore t :which-key "help")
     "ha"  'apropos-command
     "hb"  'describe-bindings
     "hc"  'describe-key-briefly
     "hf"  'describe-function
     "hF"  'describe-face
     "hh"  'help
     "hi"  'info
     "hk"  'describe-key
     "hm"  'describe-mode
     "hM"  'man
     "hP"  'describe-package
     "hv"  'describe-variable

     "m"   '(:ignore t :which-key "mode")

     "q"   '(:ignore t :which-key "quit")
     "qq"  'save-buffers-kill-terminal

     "s"   '(:ignore t :which-key "search")

     "t"   '(:ignore t :which-key "toggles")
     "tF"  'auto-fill-mode
     "th"  '(:ignore t :which-key "highlight")
     "thh" 'global-hl-line-mode
     "thl" 'highlight-lines-matching-regexp
     "thr" 'highlight-regexp
     "thu" 'unhighlight-regexp
     "thU" 'hi-lock-mode
     "tl"  'toggle-truncate-lines
     "tn"  'display-line-numbers-mode
     "tw"  'whitespace-mode

     "T"   '(:ignore t :which-key "UI toggles/themes")
     "Tf"  'fringe-foo
     "TF"  'toggle-frame-fullscreen
     "TM"  'toggle-frame-maximized
     "Tm"  'menu-bar-mode
     "Ts"  'load-theme
     "Tt"  'tool-bar-mode

     "w"   '(evil-window-map :which-key "window")

     "z"   '(:ignore t :which-key "zoom")
     "zz"  'text-scale-adjust
     "zi"  'text-scale-increase
     "zo"  'text-scale-decrease
     "z0"  'text-scale-reset)

    (general-define-key
     :keymaps 'evil-window-map
     "d" 'evil-window-delete
     "F" 'make-frame))
#+END_SRC

Restart Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :commands restart-emacs
    :general (tyrant-def "qR" 'reload-and-restart-emacs)
    :config
    (defun reload-and-restart-emacs ()
      "Reload Emacs configuration and restart Emacs."
      (interactive)
      (require 'org)
      (org-babel-tangle-file "/vcsh:dotfiles:~/.emacs.d/emacs.org")
      ;; (setq restart-emacs-restore-frames t)
      (restart-emacs)))
#+END_SRC

** Multiple Cursors

Edit text with multiple cursors.

#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :diminish
    :general
    (general-define-key
     :states '(normal visual)
     "gsm" 'evil-mc-make-all-cursors
     "gsu" 'evil-mc-undo-last-added-cursor
     "gsq" 'evil-mc-undo-all-cursors
     "gss" 'evil-mc-pause-cursors
     "gsr" 'evil-mc-resume-cursors
     "gsf" 'evil-mc-make-and-goto-first-cursor
     "gsl" 'evil-mc-make-and-goto-last-cursor
     "gsh" 'evil-mc-make-cursor-here
     "M-p" 'evil-mc-make-and-goto-prev-cursor
     "gsP" 'evil-mc-skip-and-goto-prev-cursor
     "C-t" 'evil-mc-skip-and-goto-next-match
     "C-p" 'evil-mc-make-and-goto-prev-match
     "gsp" 'evil-mc-skip-and-goto-prev-match
     "C-x" 'evil-mc-skip-and-goto-next-match
     ;; workman vim bindings
     "gsn" 'evil-mc-make-cursor-move-next-line
     "gse" 'evil-mc-make-cursor-move-prev-line
     "M-k" 'evil-mc-make-and-goto-next-cursor
     "gsK" 'evil-mc-skip-and-goto-next-cursor
     "C-k" 'evil-mc-make-and-goto-next-match
     "gsk" 'evil-mc-skip-and-goto-next-match
     "C-n" 'evil-mc-make-cursor-move-next-line
     "C-e" 'evil-mc-make-cursor-move-prev-line)
    (general-define-key
     :states 'visual
     "gsi" 'evil-mc-make-cursor-in-visual-selection-beg
     "gsa" 'evil-mc-make-cursor-in-visual-selection-end)
    (general-define-key
     :states 'normal
     "<escape>" 'evil-mc-undo-all-cursors)
    (general-define-key
     "C-<down-mouse-1>" nil
     "C-<mouse-1>" 'evil-mc-toggle-cursor-on-click)
    :config
    (global-evil-mc-mode 1))
#+END_SRC

** Completion

*** Auto-Completion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish
    :hook (after-init . global-company-mode)
    :config
    ;; tab key indents and completes
    (setq tab-always-indent 'complete)
    (advice-add 'completion-at-point :override 'company-complete)
    (defun company-backward-kill-line (arg)
      (interactive "p")
      (company-abort)
      (kill-line (- 1 arg)))
    (defun company-delete-backward-word ()
      (interactive)
      (company-abort)
      (evil-delete-backward-word))
    ;; For some reason binding C-u doesn't work in the :general keyword.
    (general-define-key
     :keymaps 'company-active-map
     "C-u" 'company-backward-kill-line
     "C-w" 'company-delete-backward-word))
#+END_SRC

*** Incremental Completion

Use ivy for generic input completion.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish
    :hook (after-init . ivy-mode)
    :general
    (general-define-key
     :keymaps 'ivy-minibuffer-map
     "C-u"     'backward-kill-line
     "C-w"     'evil-delete-backward-word
     "C-b"     'ivy-scroll-down-command
     "C-f"     'ivy-scroll-up-command
     "<prior>" 'ivy-previous-history-element
     "<next>"  'ivy-next-history-element)
    :config
    (setq ivy-use-virtual-buffers t
          ivy-count-format "(%d/%d) "
          ivy-magic-tilde nil
          ivy-initial-inputs-alist nil
          ivy-re-builders-alist '((t . ivy--regex-ignore-order))))

  (use-package counsel
    :diminish
    :after ivy
    :general
    (tyrant-def
      "so" 'swiper
      "sr" 'counsel-rg
      "ss" 'counsel-ag)
    :config (counsel-mode))
#+END_SRC

*** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :hook ((prog-mode org-mode) . yas-minor-mode)
    :general
    (tyrant-def
      "i"   '(:ignore t :which-key "insert")
      "is"  'yas-insert-snippet
      "iS"  '(:ignore t :which-key "snippet")
      "iSv" 'yas-visit-snippet-file
      "iSn" 'yas-new-snippet)
    :config
    (yas/initialize))

  (use-package yasnippet-snippets
    :after yasnippet)
#+END_SRC

** Smartparens

Insert and delete parentheses and other pairs more intelligently.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish
    :config
    (require 'smartparens-config)
    (dolist (mode '(awk c c++ css go java js nix perl rust sh))
      (sp-local-pair (intern (concat (symbol-name mode) "-mode")) "{" nil
                     :post-handlers '(:add ("||\n[i]" "RET"))))
    (smartparens-global-mode))
#+END_SRC

** Spell Check

Activate spell checker automatically in text mode, or manually with
keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :diminish
    :hook ((org-mode markdown-mode) . flyspell-mode)
    :general
    (tyrant-def
      "ts"  'flyspell-mode
      "tS"  'flyspell-prog-mode))
#+END_SRC

** Proportional Fonts

Use a mix of proportional fonts and fixed-width fonts where
appropriate. This applies to any mode based on text-mode, including
org and markdown.

#+BEGIN_SRC emacs-lisp
  (use-package mixed-pitch
    :diminish
    :general
    (tyrant-def "tm" 'mixed-pitch-mode)
    :commands mixed-pitch-mode
    :hook (org-mode . mixed-pitch-mode))
#+END_SRC

** Colors

Rainbow mode sets the background of color names to display their color.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :diminish
    :general
    (tyrant-def
      "tC"  '(:ignore t :which-key "colors")
      "tCc" 'rainbow-mode))
#+END_SRC

* Org Mode

#+BEGIN_SRC emacs-lisp
  (use-package org
    :hook (org-mode . org-indent-mode)
    :general
    (tyrant-def
      "o"   '(:ignore t :which-key "org")
      "oa"  'org-agenda-default
      "oc"  'org-capture
      "ol"  'org-store-link
      "oo"  'org-agenda
      "oO"  'org-clock-out
      "oq"  'org-clock-cancel
      "fp"  'find-plan-file)
    (tyrant-def org-mode-map
      "m,"  'org-ctrl-c-ctrl-c
      "m'"  'org-edit-special
      "m:"  'org-set-tags-command
      "m."  'org-time-stamp
      "ma"  'org-attach
      "mA"  'org-archive-subtree
      "mB"  '(:keymap org-babel-map :which-key "babel")
      "mC"  'org-clone-subtree-with-time-shift
      "md"  'org-deadline
      "me"  'org-export-dispatch
      "mI"  'org-clock-in
      "ml"  'org-insert-link
      "mn"  'org-toggle-narrow-to-subtree
      "mO"  'org-clock-out
      "mp"  'org-set-property
      "mq"  'org-clock-cancel
      "mR"  'org-refile
      "ms"  'org-schedule
      "mt"  'org-todo
      "mT"  '(:ignore t :which-key "toggles")
      "mTi" 'org-toggle-inline-images
      "mTl" 'org-toggle-link-display
      "mTo" 'org-toggle-ordered-property)
    (tyrant-def
      :definer 'minor-mode
      :keymaps 'org-src-mode
      "m," 'org-edit-src-exit
      "mc" 'org-edit-src-exit
      "mk" 'org-edit-src-abort
      "ma" 'org-edit-src-abort)
    :config
    (defun org-agenda-default ()
      (interactive)
      (org-agenda nil "n"))
    (defun my/get-org-files ()
      (directory-files org-directory t "\.org$"))
    (defun find-plan-file ()
      (interactive)
      (find-file-existing "~/org/plan.org"))
    (add-to-list 'org-modules 'org-attach)
    (add-to-list 'org-modules 'org-depend)
    (add-to-list 'org-modules 'org-habit)
    (setq holiday-bahai-holidays nil
          holiday-hebrew-holidays nil
          holiday-islamic-holidays nil
          holiday-oriental-holidays nil
          holiday-other-holidays '((holiday-fixed 5 5 "Cinco de Mayo")))
    (setq org-agenda-files '("~/org/plan.org" "~/org/training.org")
          org-agenda-span 'day
          org-agenda-todo-ignore-scheduled t
          org-capture-templates
          '(("t" "Task" entry (file+headline "~/org/plan.org" "Tasks")
             "* TODO %?\n %i\n  %a\n")
            ("a" "Appointment" entry (file+headline "~/org/plan.org" "Calendar")
             "* %?\n %i\n  %a\n")
            ("f" "FOCUS Task" entry (file+headline "~/org/plan.org" "FOCUS")
             "* TODO %?\n %i\n  %a\n"))
          org-default-notes-file "~/org/inbox.org"
          org-image-actual-width nil
          org-link-abbrev-alist '(("attach" . org-attach-expand-link))
          org-outline-path-complete-in-steps nil
          org-refile-allow-creating-parent-nodes 'confirm
          org-refile-targets '((my/get-org-files :maxlevel . 3))
          org-refile-use-outline-path 'file
          org-return-follows-link t
          org-startup-folded 'showall
          org-startup-with-inline-images t
          org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "DONE(d!)"))))

  (use-package org-indent
    :diminish
    :commands org-indent-mode)

  (use-package org-bullets
    :commands org-bullets-mode
    :hook (org-mode . org-bullets-mode))

  (use-package evil-org
    :diminish
    :after (evil evil-collection org)
    :hook (org-mode . evil-org-mode)
    :config
    (evil-org-set-key-theme)
    (evil-define-key 'normal outline-mode-map
      (kbd "TAB") 'org-cycle
      "["  nil
      "]"  nil
      "]]" 'outline-next-visible-heading
      "[[" 'outline-previous-visible-heading
      "^"  'evil-first-non-blank)
    (evil-define-key '(normal visual) evil-org-mode-map
      (kbd "RET")       'evil-org-return
      (kbd "<backtab>") 'org-shifttab)
    (workman-translate-keys 'org-mode
                            'evil-org-mode-map
                            '(normal motion visual))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (workman-translate-keys 'org-mode 'org-agenda-mode-map))
#+END_SRC

** Reminders

Set up desktop notifications for org agenda items.

#+BEGIN_SRC emacs-lisp
  (use-package appt
    :defer 5
    :config
    (defun alert-appt-display (minutes-until _time msg)
      (require 'notifications)
      (notifications-notify
       :app-icon (concat user-emacs-directory "Org-mode-unicorn.svg")
       :title (concat minutes-until " Minute Reminder")
       :body msg))

    (setq appt-time-msg-list nil)  ;; clear existing appt list
    (setq appt-display-format 'window
          appt-display-interval 30
          appt-display-mode-line nil
          appt-disp-window-function #'alert-appt-display
          appt-message-warning-time 60)
    (appt-activate 1)
    (org-agenda-to-appt)
    (run-at-time "24:01" 3600 'org-agenda-to-appt)
    (add-hook 'org-agenda-finalize-hook 'org-agenda-to-appt))
#+END_SRC

https://joonro.github.io/blog/posts/toast-notifications-org-mode-windows.html

* Tools

** Inferior Interpreters

Comint mode runs interpreters in a buffer, adding common functionality
for line editing, history, keybindings, etc.

#+BEGIN_SRC emacs-lisp
  (use-package comint
    :general
    (tyrant-def comint-mode-map
      "m," 'comint-get-next-from-history
      "m." 'comint-insert-previous-argument
      "ml" 'comint-dynamic-list-input-ring)
    (general-define-key
     :keymaps 'comint-mode-map
     :states 'insert
     "SPC"       'comint-magic-space
     "C-a"       'move-beginning-of-line
     "C-e"       'move-end-of-line
     "C-k"       'kill-line
     "<prior>"   'comint-previous-matching-input-from-input
     "<next>"    'comint-next-matching-input-from-input
     "S-<prior>" 'scroll-down-command
     "S-<next>"  'scroll-up-command)
    :config
    (setq comint-completion-addsuffix '("/" . " ")))
#+END_SRC

*** Shell

Set up inferior shell, for running a shell in an Emacs buffer.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package shell
    :general
    (tyrant-def
      "asi" 'shell)
    (general-define-key
     :keymaps 'shell-mode-map
     :states 'insert
     "TAB" 'company-complete
     "C-w" 'backward-delete-word)
    :config

    ;; Use Emacs as editor.
    (when (daemonp)
      (add-hook 'shell-mode-hook 'with-editor-export-editor))

    ;; Recognize the password prompt from my doas alias.
    (setq comint-password-prompt-regexp
          (concat comint-password-prompt-regexp
                  "\\|^doas (.*@.*) password: \\'"))

    ;;; Make C-w behave like bash:

    ;; https://www.emacswiki.org/emacs/BackwardDeleteWord
    (defun delete-word (arg)
      "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
      (interactive "p")
      (if (use-region-p)
          (delete-region (region-beginning) (region-end))
        (delete-region (point) (progn (forward-word arg) (point)))))

    (defun backward-delete-word (arg)
      "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
      (interactive "p")
      (delete-word (- arg)))

    ;; Redefine a few word characters.
    (add-hook 'shell-mode-hook
              (lambda ()
                (dolist (c '(?_ ?- ?.))
                  (modify-syntax-entry c "w"))
                (modify-syntax-entry ?/ "-")))

    ;;; Kill buffer when the shell exits.
    ;; https://emacs.stackexchange.com/a/48307

    (defun add-process-sentinel (sentinel &optional process)
      "Add SENTINEL to PROCESS.
  PROCESS defaults to the process of the current buffer.
  Use this function with care.
  If there is already a process sentinel SENTINEL is used as after-advice.
  That can fail if the process sentinel is reset by some other function."
      (unless process
        (setq process (get-buffer-process (current-buffer))))
      (let ((old (process-sentinel process)))
        (cond
         ((symbolp old)
          (advice-add old :after sentinel))
         ((null old)
          (set-process-sentinel process sentinel))
         (t (warn "Cannot set sentinel %S for process %S." sentinel process)))))

    (defun kill-shell-buffer-on-exit ()
      "Custom `shell-mode' behaviours."
      ;; Kill the buffer when the shell process exits.
      (add-process-sentinel
       (lambda (process signal)
         (and (memq (process-status process) '(exit signal))
              (buffer-live-p (process-buffer process))
              (evil-delete-buffer (process-buffer process))))))

    (add-hook 'shell-mode-hook 'kill-shell-buffer-on-exit)

    <<apt-progress-bars>>)
#+END_SRC

**** Bash Completion

Bash completion is disabled for now. It requires configuration on the
shell side too, and I'm not 100% sure I like it anyway.

#+BEGIN_SRC emacs-lisp
  (use-package bash-completion
    :commands (bash-completion-dynamic-complete
               bash-completion-dynamic-complete-nocomint)
    :init (add-hook 'shell-dynamic-complete-functions
                    'bash-completion-dynamic-complete))
#+END_SRC

**** Apt Progress Bars

Show =apt= progress bars in the minibuffer.

#+NAME: apt-progress-bars
#+BEGIN_SRC emacs-lisp :tangle no
  (advice-add 'ansi-color-apply-on-region :before 'ora-ansi-color-apply-on-region)

  (defun ora-ansi-color-apply-on-region (begin end)
    "Fix progress bars for e.g. apt(8).
  Display progress in the mode line instead."
    (let ((end-marker (copy-marker end))
          mb)
      (save-excursion
        (goto-char (copy-marker begin))
        (while (re-search-forward "\0337" end-marker t)
          (setq mb (match-beginning 0))
          (when (re-search-forward "\0338" end-marker t)
            (let ((progress (buffer-substring-no-properties
                             (+ mb 2) (- (point) 2))))
              (delete-region mb (point))
              (ora-apt-progress-message progress)))))))

  (defun ora-apt-progress-message (progress)
    (message
     (replace-regexp-in-string
      "%" "%%"
      (ansi-color-apply progress))))
#+END_SRC

https://oremacs.com/2019/03/24/shell-apt/

** Emacs Shell

A shell written entirely in elisp.

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :commands eshell
    :general
    (tyrant-def
      "ase" 'eshell)
    :config
    ;; Open in new window
    (add-to-list 'display-buffer-alist
                 '("\\`\\*e?shell" display-buffer-pop-up-window))
    (setq eshell-banner-message ""
          eshell-destroy-buffer-when-process-dies t)
    (setq eshell-prompt-function
          (lambda ()
            (concat
             (when (not (= 0 eshell-last-command-status))
               (concat (number-to-string eshell-last-command-status) "|"))
             (abbreviate-file-name (eshell/pwd))
             (if (= (user-uid) 0) "# " "$ ")))))
#+END_SRC

** Ledger

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :mode "\\.ledger\\'"
    :general
    (tyrant-def ledger-mode-map
      "mb"  'ledger-post-edit-amount
      "mc"  'ledger-toggle-current
      "md"  'ledger-delete-current-transaction
      "mf"  'ledger-occur
      "mi"  'ledger-add-transaction
      "ml"  'ledger-display-ledger-stats
      "mp"  'ledger-display-balance-at-point
      "mr"  'ledger-reconcile
      "mR"  'ledger-report
      "ms"  'ledger-sort-region
      "mt"  'ledger-insert-effective-date)
    (tyrant-def ledger-reconcile-mode-map
      "m," 'ledger-reconcile-toggle
      "ma" 'ledger-reconcile-quit
      "mk" 'ledger-reconcile-quit
      "mt" 'ledger-reconcile-change-target
      "m RET" 'ledger-reconcile-finish)
    (general-define-key
     :states  '(normal visual)
     :keymaps 'ledger-mode-map
     "gj"  'ledger-navigate-next-xact-or-directive
     "gk"  'ledger-navigate-prev-xact-or-directive
     "M-j" 'ledger-navigate-next-xact-or-directive
     "M-k" 'ledger-navigate-prev-xact-or-directive
     "[["  'ledger-navigate-prev-xact-or-directive
     "]]"  'ledger-navigate-next-xact-or-directive
     "("   'ledger-navigate-beginning-of-xact
     ")"   'ledger-navigate-end-of-xact
     "="   (general-key-dispatch 'evil-indent
             "=" 'ledger-post-align-dwim))
    (general-define-key
     :states  'visual
     :keymaps 'ledger-mode-map
     "="   'evil-indent)
    (general-define-key
     :states  'normal
     :keymaps 'ledger-reconcile-mode-map
     "a"   'ledger-reconcile-add
     "c"   'ledger-reconcile-toggle
     "d"   'ledger-reconcile-delete
     "t"   'ledger-reconcile-change-target
     "gr"  'ledger-reconcile-refresh
     "q"   'ledger-reconcile-quit
     "ZQ"  'ledger-reconcile-quit
     "ZZ"  'ledger-reconcile-finish)
    (general-define-key
     :states  'normal
     :keymaps 'ledger-report-mode-map
     "q"   'ledger-report-quit)
    (workman-translate-keys 'ledger-mode
                            'ledger-mode-map
                            'normal)
    :config
    (setq ledger-init-file-name ".ledgerrc"
          ledger-post-amount-alignment-column 52
          ledger-reconcile-buffer-line-format "%(date)s  %-30(payee)s %-25(account)s %10(amount)s\n"
          ledger-reconcile-buffer-account-max-chars 25
          ledger-reconcile-buffer-payee-max-chars 30)
    (dolist (report '("summary" "balancesheet" "incomestatement" "budget"
                      "reconciled" "reimbursements" "monthly"))
      (add-to-list 'ledger-reports
                   (list report
                         (concat "./run-report.sh "
                                 report
                                 " --force-color -f %(ledger-file)"))))

    ;; Only reconcile with real transactions
    (defun ledger-use-real-transactions (&rest ignore)
      (write-region "--real\n" nil ledger-init-file-name))
    (defun ledger-use-all-transactions (&rest ignore)
      (when (file-exists-p ledger-init-file-name)
        (delete-file ledger-init-file-name)))
    (advice-add 'ledger-reconcile :before #'ledger-use-real-transactions)
    (advice-add 'ledger-reconcile-quit :after #'ledger-use-all-transactions)
    (advice-add 'ledger-reconcile-finish :after #'ledger-use-all-transactions))
#+END_SRC

** File Management

#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t)
  (setq dired-guess-shell-alist-user
        '(("\\.info\\.json$" "ytdl")
          ("\\.pdf$" "zathura")
          ("\\.(avi|mkv|mp4|webm)$" "mpv -fs")
          ("\\.(flac|m4a|mp3|ogg|opus)$" "mpv")
          ("\\.jpg$" "feh --cycle-once -dFZD-10 *")))
  (setq image-dired-external-viewermage nil)
  (add-to-list 'directory-abbrev-alist
    '("^/egnyte" . "/davs:focusengineering.egnyte.com:/webdav/Shared"))
#+END_SRC

** Documentation

Configure the built-in Info documentation reader.

#+BEGIN_SRC emacs-lisp
  (use-package info
    :config
    (evil-add-yneo-bindings Info-mode-map 'normal
      "k" 'evil-search-next
      "?" 'evil-search-backward))
#+END_SRC

Enhance the built-in Emacs help with much more contextual information

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :general
    (general-define-key
     [remap describe-function] #'helpful-callable
     [remap describe-variable] #'helpful-variable
     [remap describe-key] #'helpful-key))
#+END_SRC

** Feed Aggregator

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :commands elfeed-org)

  (use-package elfeed
    :general (tyrant-def "af" 'elfeed)
    :config
    (elfeed-org)
    (setq elfeed-db-directory "~/.local/share/elfeed"
          elfeed-enclosure-default-dir "~/tmp/"
          elfeed-search-filter "@1-month-ago +unread "
          rmh-elfeed-org-files (list (concat org-directory "/links.org")))
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :feed-title "LWN\\.net"
                                  :entry-title '("Kernel prepatch"
                                                 "Security-updates"
                                                 "Weekly Edition")
                                  :remove 'unread))
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :feed-title "Slate Star Codex"
                                  :entry-title '("Link" "OT" "Thread"
                                                 "Highlights")
                                  :remove 'unread))
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :feed-title "Barbell Logic Channel"
                                  :entry-title "^#[0-9]"
                                  :remove 'unread)))
#+END_SRC

** Epub Reader

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode))
#+END_SRC

** Password Manager

#+BEGIN_SRC emacs-lisp
  (use-package pass
    :general (tyrant-def "ap" 'pass))
#+END_SRC

** Email Client

=mu4e= is an email client for Emacs based on the =mu= (maildir-utils)
search engine.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :commands (mu4e mu4e~headers-jump-to-maildir)
    :general
    (defun mu4e-inbox ()
      (interactive)
      (mu4e~headers-jump-to-maildir "/Inbox"))
    (tyrant-def "am" 'mu4e-inbox)
    :config
    (setq mu4e-maildir       "~/mail"
          mu4e-sent-folder   "/Sent Items"
          mu4e-drafts-folder "/Drafts"
          mu4e-trash-folder  "/Trash"
          mu4e-get-mail-command "mbsync -c ~/.config/isync/mbsyncrc -a"))
#+END_SRC

Support links to mu4e messages from Org.

#+BEGIN_SRC emacs-lisp
  (use-package org-mu4e
    :after mu4e
    :config
    (setq org-mu4e-link-query-in-headers-mode t))
#+END_SRC

Show email threads in a unified conversation view.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e-conversation
    :after mu4e
    :init
    (defalias 'copy-seq 'cl-copy-seq)
    :config
    (global-mu4e-conversation-mode))
#+END_SRC

** Slack

#+BEGIN_SRC emacs-lisp
  (use-package slack
    :general
    (tyrant-def
      "aSs" 'slack-start
      "aSc" 'slack-channel-select
      "aSg" 'slack-group-select)
    :config
    (setq slack-buffer-emojify t
          slack-prefer-current-team t)
    (require 'password-store)
    (slack-register-team
     :name "intellectuallp"
     :default t
     :token (password-store-get "personal/slack.com/intellectuallp_token"))
    (slack-start))
#+END_SRC

* Projects

The =projectile= package provides useful project-centric commands.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish
    :defer t
    :config
    (setq counsel-projectile-switch-project-action 'dired))
#+END_SRC

The =counsel-projectile= package enhances =projectile= with =ivy= completion.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :defer t
    :general
    (tyrant-def
      "p"  '(:keymap projectile-command-map
             :package counsel-projectile
             :which-key "projects"))
    :config
    (counsel-projectile-mode))
#+END_SRC

* Version Control

Magit is the best porcelain for git.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :diminish auto-revert-mode
    :general
    (tyrant-def
      "g"  '(:ignore t :which-key "git")
      "gc" 'magit-clone
      "gf" 'magit-file-dispatch
      "gm" 'magit-dispatch
      "gs" 'magit-status))

  (use-package evil-magit
    :after (evil evil-collection magit)
    :config
    (when evil-workman
      (evil-define-key '(normal visual) magit-mode-map
        "\C-n" 'magit-section-forward
        "gn"   'magit-section-forward-sibling
        "\C-e" 'magit-section-backward
        "ge"   'magit-section-backward-sibling
        "n"    'evil-next-visual-line
        "e"    'evil-previous-visual-line
        "j"    nil
        "jj"   'evil-yank-line
        "jr"   'magit-show-refs
        "js"   'magit-copy-section-value
        "jb"   'magit-copy-buffer-revision
        "y"    nil
        "/"    'evil-search-forward
        "k"    'evil-search-next
        "K"    'evil-search-previous)
      (evil-define-key 'visual magit-mode-map
        "j"    'evil-yank
        "y"    nil)
      (evil-define-key '(normal visual) magit-diff-mode-map
        "gn"   'magit-section-forward)
      (evil-define-key '(normal visual) 'magit-blob-mode-map
        "gn"   'magit-blob-next
        "ge"   'magit-blob-previous)
      (evil-define-key '(normal visual) 'git-commit-mode-map
        "gn"   'git-commit-next-message
        "ge"   'git-commit-prev-message)
      (evil-define-key 'normal 'magit-blame-read-only-mode-map
        "n"    'evil-next-visual-line
        "\C-n" 'magit-blame-next-chunk
        "gn"   'magit-blame-next-chunk
        "gN"   'magit-blame-next-chunk-same-commit
        "e"    'evil-previous-visual-line
        "\C-e" 'magit-blame-previous-chunk
        "ge"   'magit-blame-previous-chunk
        "gE"   'magit-blame-previous-chunk-same-commit)
      (evil-define-key 'normal git-rebase-mode-map
        "n"    'evil-next-visual-line
        "e"    'evil-previous-visual-line
        "\M-n" 'git-rebase-move-line-down
        "\M-e" 'git-rebase-move-line-up
        "h"    'git-rebase-edit)))
#+END_SRC

Add TRAMP method to integrate Magit with vcsh.
https://github.com/magit/magit/issues/2939

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (add-to-list 'tramp-methods
                 '("vcsh"
                   (tramp-login-program "vcsh")
                   (tramp-login-args (("enter") ("%h")))
                   (tramp-remote-shell "/bin/sh")
                   (tramp-remote-shell-args ("-c")))))
#+END_SRC

* Programming

** Syntax Checking

Check syntax and other errors on the fly.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (after-init . global-flycheck-mode)
    :general
    (tyrant-def
      "e"  '(:ignore t :which-key "errors")
      "ec" 'flycheck-clear
      "ee" 'flycheck-explain-error-at-point
      "eh" 'flycheck-describe-checker
      "eL" 'goto-flycheck-error-list
      "el" 'flycheck-list-errors
      "en" 'flycheck-next-error
      "ep" 'flycheck-previous-error
      "eS" 'flycheck-set-checker-executable
      "es" 'flycheck-select-checker
      "ev" 'flycheck-verify-checker)
    (general-define-key
     :keymaps 'flycheck-mode-map
     :states '(normal visual)
     "[e"  'flycheck-previous-error
     "]e"  'flycheck-next-error
     "[l"  'flycheck-previous-error
     "]l"  'flycheck-next-error)
    :config
    (setq flycheck-mode-line-prefix "!")
    (add-hook 'org-src-mode-hook
              (lambda () (flycheck-mode 0))))
#+END_SRC

* Languages

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.mdwn\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config (setq markdown-command "pandoc"))
#+END_SRC

** APL

#+BEGIN_SRC emacs-lisp
  (use-package gnu-apl-mode
    :disabled
    :commands gnu-apl
    :init
    (fset 'apl 'gnu-apl)
    :config
    (setq gnu-apl-show-keymap-on-startup nil
          gnu-apl-show-tips-on-start nil)
    (defun gnu-apl-input-hook ()
      (set-input-method "APL-Z"))
    (add-hook 'gnu-apl-interactive-mode-hook 'gnu-apl-input-hook)
    (add-hook 'gnu-apl-mode-hook 'gnu-apl-input-hook))

  ;; (set-fontset-font "fontset-default" '(#x2300 . #x23ff) "Iosevka Term Slab")
#+END_SRC

** C

Default to sane indent rules for C.

#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux")
  (add-hook 'c-mode-hook
            (lambda () (setq indent-tabs-mode t)))
#+END_SRC

** Go

Support for the Go programming language.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :config
    (when (executable-find "goimports")
      (setq gofmt-command "goimports"))
    (add-hook 'before-save-hook 'gofmt-before-save)
    (add-hook 'go-mode-hook
              (lambda () (setq tab-width 4)))
    (when evil-workman
      (evil-define-key 'normal go-mode-map
        "E" 'godef-describe
        "K" 'evil-search-previous)))
#+END_SRC

Show function signatures and other information in the echo area when
hovering over things.

#+BEGIN_SRC emacs-lisp
  (use-package go-eldoc
    :hook (go-mode . go-eldoc-setup))
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'")
#+END_SRC

** Lisp-like
*** Scheme

Geiser runs a scheme interpreter to interact with alongside source buffers.

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :commands run-geiser
    :config
    (evil-add-yneo-bindings 'geiser-mode-map 'normal
      "E" 'geiser-doc-symbol-at-point
      "K" 'evil-search-previous)
    (setq geiser-active-implementations '(guile)
          geiser-default-implementation 'guile
          geiser-mode-start-repl-p nil)
    (with-eval-after-load 'geiser-guile
      (add-to-list 'geiser-guile-load-path "~/src/guix"))
    (with-eval-after-load 'yasnippet
      (add-to-list 'yas-snippet-dirs "~/src/guix/etc/snippets")))
#+END_SRC

Add some extra Guix-related functionality, both for interacting with
the package manager and hacking the scheme package definitions.

#+BEGIN_SRC emacs-lisp
  (use-package guix
    :general
    (tyrant-def
      "ag" 'guix-popup))
#+END_SRC

Open files with =.guile= file extension in =scheme-mode=.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.guile\\'" . scheme-mode) t)
#+END_SRC

** sh

Configure shell script indentation style to match =shfmt=.

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :mode ("\\.shinit\\'" . sh-mode)
    :init
    (setq sh-indent-after-continuation 'always
          sh-indent-for-case-alt '+
          sh-indent-for-case-label 0)
    (defvaralias 'sh-basic-offset 'tab-width)
    (add-hook 'sh-mode-hook
              (lambda ()
                (setq indent-tabs-mode t
                      tab-width 4)))
    :config
    (defun sh-bash-completion ()
      (interactive)
      (bash-completion-dynamic-complete-nocomint
       (save-excursion (sh-beginning-of-command) (point))
       (point)))
    (add-to-list 'sh-dynamic-complete-functions
                 'sh-bash-completion))
#+END_SRC

** Vimscript

#+BEGIN_SRC emacs-lisp
  (use-package vimrc-mode
    :mode "\\.vim\\(rc\\)?\\'")
#+END_SRC
